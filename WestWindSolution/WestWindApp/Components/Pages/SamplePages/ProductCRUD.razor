@page "/productcrud/{productid:int?}"

<!--
on the page directive above, a routing parameter has been add syntax: /routingname/{parametername:datatype}
this will allow an integer value to be passed to this page
the routing parameter (productid) needs to be declare in your code area below

if you have the situation where your receive page may or maynot receive a parameter
value THEN make the datatype nullable (?)

if your routing parameter is a string, you do NOT need to specify the routing parameter datatype HOWEVER you
will still want to place a ? (nullable) character at the end of the routing parameter name (eg {StringPkey?})
-->

<PageTitle>Product CRUD</PageTitle>
@rendermode InteractiveServer

<!-- Additional namespaces-->
@using WestWindSystem.BLL;
@using WestWindSystem.Entities;

<h1>Product CRUD</h1>
<cite> ... demonstrating CRUD using EditForm</cite>

<br />
<br />

@if (feedBackMsg.Length > 0)
{
    <div class="alert alert-info">
        <p>@feedBackMsg</p>
    </div>
}

@if (errorMsgs.Count > 0)
{
    <div class="alert alert-danger">
        <p>Please fix the following issues:</p>
        <ul>
            @foreach (var error in errorMsgs)
            {
                <li>@error</li>
            }
        </ul>
    </div>
}

<br />
<br />
<!-- EditForm

this groups a bunch of controls as a single form
allows for adding additonal options to integrate with your form controls
contains a set of enhanced input controls

register an EditContext instance for this form

DataAnnotationsValidator

the DataAnnotationsValidator component is used within an
EditForm to enable validation based on data annotations
        applied to model properties.

ValidationSummary

displays a list of all validation errors
show a summary of errors at the top of the form
errors can be from model properties or custom messages
this is optional

ValidationMessage

displays the message associated with the indicated entity field
this is optional

-->

<EditForm EditContext="editContext">
    <DataAnnotationsValidator/>
    <ValidationSummary/>

    <!--
        the form controls will appear between the start and end EditForm tags

        what about format layout
        you can use your normal formatting (eg bootstrap) in laying out your form
    -->
    <div class="row">
        <div class="offset-1 col-md-4">
            <label for="productid" class="form-label">Product ID</label>

            <!--
            We can use enhanced input type controls with EditForm
            No type attribute is need for the EditForm control, the type in
               is built into the control
            Binding parameter: bind-Value is required when using EditForm controls

            Since the pkey for Productid is an identity key, the user should not be
                able to alter the field. Use the attribute "readonly" to restrict data entry
            -->
            <InputNumber id="productid" class="form-control"
                        @bind-Value="currentProduct.ProductID"
                        style="width: 75px;" readonly />
            <br/>
            <label for="productname" class="form-label">Name</label>
            <InputText id="productname" class="form-control"
                        @bind-Value="currentProduct.ProductName" />

            <!--
                immediately after your input control you can add the validation
                    message tag IF you want your messages immediately after the control

                you can omit this control and still display an error message associated
                    with this control with the ValidationSummary
            -->
            <ValidationMessage For="@(() => currentProduct.ProductName)" />

            <!-- Foreign Keys-->
            <!--
                foreign keys should be handled in a way that the contents
                    for selection is limited to the possible values on
                    the database
            -->
            <br />
            <label for="categoryid" class="form-label">Category</label>
            <InputSelect id="categoryid" @bind-Value="currentProduct.CategoryID" class="form-control">
                <option value="0">... select category ...</option>
                @foreach(var item in categoryList)
                {
                    <option value="@item.CategoryID">@item.CategoryName</option>
                }
            </InputSelect>
            <!--
                the validation messages that will appear in this control will
                    come from custom validation done within the event button method
            -->
            <ValidationMessage For="@(() => currentProduct.CategoryID)" />
            <br />
            <label for="supplierid" class="form-label">Supplier</label>
            <InputSelect id="supplierid" @bind-Value="currentProduct.SupplierID" class="form-control">
                <option value="0">... select supplier ...</option>
                @foreach (var item in supplierList)
                {
                    <option value="@item.SupplierID">@item.CompanyName</option>
                }
            </InputSelect>
            <!--
                the validation messages that will appear in this control will
                    come from custom validation done within the event button method
            -->
            <ValidationMessage For="@(() => currentProduct.SupplierID)" />


        </div>
   
        <div class="offset-1 col-md-4">
            <label for="qtyperunit" class="form-label">Qty / Unit</label>
            <InputText id="qtyperunit" class="form-control"
                       @bind-Value="currentProduct.QuantityPerUnit" />
            <ValidationMessage For="@(() => currentProduct.QuantityPerUnit)" />
            <br/>
            <label for="minqty" class="form-label">Min Order Qty</label>
            <InputNumber id="minqty" class="form-control"
                       @bind-Value="currentProduct.MinimumOrderQuantity" />
            <ValidationMessage For="@(() => currentProduct.MinimumOrderQuantity)" />
            <br />
            <label for="unitprice" class="form-label">Unit Price</label>
            <InputNumber id="unitprice" class="form-control"
                         @bind-Value="FormatUnitPrice" />
            <ValidationMessage For="@(() => currentProduct.UnitPrice)" />
            <br />
            <label for="unitsonorder" class="form-label">Units on Order</label>
            <InputNumber id="unitsonorder" class="form-control"
                         @bind-Value="currentProduct.UnitsOnOrder" />
            <ValidationMessage For="@(() => currentProduct.UnitsOnOrder)" />
        </div>
    </div>
    <br/><br/>
    <div class="row">
        <div class="col-md-12 text-center">
            <button type="button" class="btn btn-outline-primary rounded-pill"
                    @onclick="OnCreate" style="width:160px;">
                Create    
            </button>
            &nbsp;&nbsp;
            <button type="button" class="btn btn-outline-primary rounded-pill"
                    @onclick="OnUpdate" style="width:160px;">
                Update
            </button>
            &nbsp;&nbsp;
            <button type="button" class="btn btn-outline-primary rounded-pill"
                    @onclick="OnDiscontinued" style="width:160px;">
                Discontinued
            </button>
            &nbsp;&nbsp;
            <button type="button" class="btn btn-outline-secondary rounded-pill"
                    @onclick="OnClear" style="width:160px;">
                Clear
            </button>
            &nbsp;&nbsp;
            <button type="button" class="btn btn-outline-secondary rounded-pill"
                    @onclick="OnSearch" style="width:160px;">
               Search
            </button>
        </div>
    </div>
</EditForm>

@code {
    private string feedBackMsg = "";
    private List<string> errorMsgs = new();


    // EditForm properties and variables

    //EditContext class instance
    //  will hold the instance of the data Model that is being maintained on the control
    private EditContext editContext;
    //will be used to place custom event validation messages into the same controls
    //  used by DataAnnotationsValidator
    private ValidationMessageStore validationMessageStore;

    //this is the instance of the entity Product that will hold the data of the form
    //this instance will be tied to the editContext
    private Product currentProduct = new();

    // foreign key fields
    [Inject]
    public CategoryServices _categoryServices { get; set; }
    private List<Category> categoryList = new();

    [Inject]
    public SupplierServices _supplierServices { get; set; }
    private List<Supplier> supplierList = new();

    [Inject]
    public ProductServices _productServices { get; set; }

    //this javascript injection is needed to used the continue dialogue prompt
    [Inject]
    public IJSRuntime jSRuntime { get; set; }

    [Inject]
    private NavigationManager _navManager { get; set; } 

    //declare the routing parameter
    //this property needs a special annotation to indicate it is a parameter
    //parameter properties need to be accessible by other pages (aka classes)
    //  therefore they need to be public
    [Parameter]
    public int? productid { get; set; }


    private decimal FormatUnitPrice
    {
        get { return Math.Round(currentProduct.UnitPrice,2); }
        set { currentProduct.UnitPrice = value; }
    }

    protected override void OnInitialized()
    {
        base.OnInitialized();

        //when the page is first rendered, we need to determined if the page was called with
        //   a pkey parameter value
        // No value: assumption is a NEW (create) product will be done, nothing to lookup
        // Yes value: assumption an existing product record will be altered or deleted
        //            the current record on the database should be displayed to the user
        //            within this method, lookup the record to display
        //since the productid is a nullable variable, add the .Value to obtain the value,
        //  and use .HasValue to test for the value

        //NOTE: the retrieval of the product instance is REQUIRED BEFORE assigning the instance
        //          to EditContext
        if(productid.HasValue)
            currentProduct = _productServices.Product_GetByID(productid.Value);

        //create the EditContext instance AND tie to the instance of the entity of the form
        editContext = new EditContext(currentProduct);

        //create validation MessageStore instance and indicate which EditContext it is
        //      associated with
        //needed for custom validation within the event code and
        //   allows the user to use the ValidationMesssage controls of the form
        validationMessageStore = new ValidationMessageStore(editContext);

        //fill the foreign key field collections
        categoryList = _categoryServices.Category_GetAll();
        supplierList = _supplierServices.Supplier_GetAll();



    }

    private void OnCreate()
    {
        //clear old messages
        feedBackMsg = "";
        errorMsgs.Clear();
        validationMessageStore.Clear();

        try
        {
            //         the first test is to check to see if there are ANY errors already caught
            //               by the form using the DataAnnotationsValidator?
            if (editContext.Validate())
            {
                //             no errors on the form at this time

                //             if there are additional custom validation of your data
                //               you can still do that within the event coding

                //             custom validation for this form will check to see if a category
                //               and supplier have been select (why: the list have a prompt that
                //               has a non valid sql foreign key value)

                //             Problem:
                //              CategoryID is an integer
                //              the default of an integer is 0 ( a value)
                //              NO foreign key/primary key on the database is 0

                //              if a proper selection is not done, then when the
                //                   record is attempted to be added to the the database
                //                   the database will thrown an exception

                //             Solution: custom validation
                if (currentProduct.CategoryID == 0)
                {
                    //                 construction of the validation message store command
                    //                  .Add to your instance of the form for the indicated field
                    //                  parameter 1: the associated field to display the message
                    //                               looking for the "field identifier"
                    //                               use nameof(xxx) to supplier the "field identifier"
                    //                       example: editContext.Field(nameof(CurrentProduct.CategoryID))
                    //                  parameter 2: the message to display
                    //                       example: "You must select a category"
                    validationMessageStore.Add(editContext.Field(nameof(currentProduct.CategoryID)),
                                                "You must select a category");
                }
                if (currentProduct.SupplierID == 0)
                {
                    validationMessageStore.Add(editContext.Field(nameof(currentProduct.SupplierID)),
                                            "You must select a supplier");
                }
                if (currentProduct.UnitPrice < 0.0m)
                {
                    validationMessageStore.Add(editContext.Field(nameof(currentProduct.UnitPrice)),
                                           "Unit price must be zero or greater.");
                }
                //             once your custom validation is done, if there was any, you can check to see
                //               what your validationMessageStore contains
                //             if there are any new messages , indicate to the form that the store has been altered
                //             to do this, we will use the Linq method .Any()  to determine if something exists
                //             NOTE: the .Any() returns only a true or false; it does NOT return an actual records
                //                   the .Where() returns actual record
                if (editContext.GetValidationMessages().Any())
                {
                    //notify the editcontext that there has been a change to the message store
                    editContext.NotifyValidationStateChanged();
                }
                else
                {
                    //the program assumes that the data is clean and can be further processed
                    //call the product services to receive the "good" data and add it to the database

                    int newProductId = _productServices.Product_Add(currentProduct);

                    //                 if an error was thrown by the ProductServices or by the database,
                    //                   control will be passed to the catch
                    //                 if no error was thrown by the ProductServices or by the database.
                    //                   one assumes the data is on the database: success
                    //                 you need to communicate with the user this success
                    feedBackMsg = $"Product {currentProduct.ProductName} (ID: {newProductId}) has been added to database.";
                }

            }
        }
        catch (Exception ex)
        {
            feedBackMsg = $"System Error: {ex.Message}";
        }

    }

    private void OnUpdate()
    {
        //clear old messages
        feedBackMsg = "";
        errorMsgs.Clear();
        validationMessageStore.Clear();

        try
        {
            if (editContext.Validate())
            {
                if (currentProduct.CategoryID == 0)
                {
                    validationMessageStore.Add(editContext.Field(nameof(currentProduct.CategoryID)),
                                                "You must select a category");
                }
                if (currentProduct.SupplierID == 0)
                {
                    validationMessageStore.Add(editContext.Field(nameof(currentProduct.SupplierID)),
                                            "You must select a supplier");
                }
                if (currentProduct.UnitPrice < 0.0m)
                {
                    validationMessageStore.Add(editContext.Field(nameof(currentProduct.UnitPrice)),
                                           "Unit price must be zero or greater.");
                }
                if (editContext.GetValidationMessages().Any())
                {
                    //notify the editcontext that there has been a change to the message store
                    editContext.NotifyValidationStateChanged();
                }
                else
                {
                    int rowsaffected = _productServices.Product_Update(currentProduct);

                    //Question: DID you ACTUALLY change any records?
                    //situation: an update was attempted but no records on the database were
                    //              actually change AND the action did NOT abort
                    //in this case rowsafftected = 0

                    if (rowsaffected == 0)
                    {
                        feedBackMsg = $"Product {currentProduct.ProductName} (ID: {currentProduct.ProductID}) change failed.";
                    }
                    else
                    {
                        feedBackMsg = $"Product {currentProduct.ProductName} (ID: {currentProduct.ProductID}) change was save.";
                    }
                }
            }
        }
        catch (Exception ex)
        {
            feedBackMsg = $"System Error: {ex.Message}";
        }
    }

    private void OnDiscontinued()
    {
        //clear old messages
        feedBackMsg = "";
        errorMsgs.Clear();
        validationMessageStore.Clear();

        try
        {
            //the custom validation is dependent on how you manage your
            //  product service method
            //a) if you are NOT going to use the incoming data to update
            //   your product before setting the Discontinued field to true
            //   then you do NOT need to do this custom validation
            //OR
            //b) you are going to allow update and discontinue to happen on
            //      the discontinue THEN you DO need to do this custom validation
            if (editContext.Validate())
            {
                if (currentProduct.CategoryID == 0)
                {
                    validationMessageStore.Add(editContext.Field(nameof(currentProduct.CategoryID)),
                                                "You must select a category");
                }
                if (currentProduct.SupplierID == 0)
                {
                    validationMessageStore.Add(editContext.Field(nameof(currentProduct.SupplierID)),
                                            "You must select a supplier");
                }
                if (currentProduct.UnitPrice < 0.0m)
                {
                    validationMessageStore.Add(editContext.Field(nameof(currentProduct.UnitPrice)),
                                           "Unit price must be zero or greater.");
                }
                if (editContext.GetValidationMessages().Any())
                {
                    //notify the editcontext that there has been a change to the message store
                    editContext.NotifyValidationStateChanged();
                }
                else
                {
                    int rowsaffected = _productServices.Product_LogicalDelete(currentProduct);

                    //Question: DID you ACTUALLY change any records?


                    if (rowsaffected == 0)
                    {
                        feedBackMsg = $"Product {currentProduct.ProductName} (ID: {currentProduct.ProductID}) discontinue failed.";
                    }
                    else
                    {
                        feedBackMsg = $"Product {currentProduct.ProductName} (ID: {currentProduct.ProductID}) has been disconntinued.";
                    }
                }
            }
        }
        catch (Exception ex)
        {
            feedBackMsg = $"System Error: {ex.Message}";
        }
    }

    // if you are going to physically remove a record that is of importance
    //  CONSIDER prompting the user for confirmation BEFORE physically removing
    //  the record
    // private void OnRemoval()
    // {
    //     //clear old messages
    //     feedBackMsg = "";
    //     errorMsgs.Clear();
    //     validationMessageStore.Clear();

    //     try
    //     {
    //         int rowsaffected = _productServices.Product_PhysicalDelete(currentProduct);

    //         //Question: DID you ACTUALLY change any records?

    //         if (rowsaffected == 0)
    //         {
    //             feedBackMsg = $"Product {currentProduct.ProductName} (ID: {currentProduct.ProductID}) discontinue failed.";
    //         }
    //         else
    //         {
    //             feedBackMsg = $"Product {currentProduct.ProductName} (ID: {currentProduct.ProductID}) has been disconntinued.";
    //         }

    //     }
    //     catch (Exception ex)
    //     {
    //         feedBackMsg = $"System Error: {ex.Message}";
    //     }
    // }

    //this event will prompt the user to continue by using a javascript dialogue
    //the program needs to WAIT until the user responses
    //In this situation, the dialogue should be run in a separate task
    //NOTE: the return datatype for this instance will be changed to async Task
    private async Task OnClear()
    {
        //clear old messages
        feedBackMsg = "";
        errorMsgs.Clear();

        //setup and execute the prompt dialogue
        object[] messagestring = new object[]
            {"Clearing the page will lose all unsaved data. Do you wish to continue?"};
        if(await(jSRuntime.InvokeAsync<bool>("confirm",messagestring)))
        {
            //remove any old custom error messages placed in the Validation Message store
            validationMessageStore.Clear();

            //clear out the old values
            //clear the current product instance of any data (not using local variables)
            //notice that the "system" constructor is used as the entity has NO constructor code within it
            currentProduct = new Product();
            // currentProduct.ProductName = "unknown";
            // currentProduct.QuantityPerUnit = "unknown";

            //         IMPORTANT!!!!!!!!!!!!!!!!!!
            //         the editContext is associated with the current product instance
            //         the editContext REQUIRES to be reset to the NEW current product instance
            editContext = new EditContext(currentProduct);
        }


    }

    private async Task OnSearch()
    {
        //clear old messages
        feedBackMsg = "";
        errorMsgs.Clear();

        //setup and execute the prompt dialogue
        object[] messagestring = new object[]
            {"Leaving the page will lose all unsaved data. Do you wish to continue?"};
        if (await (jSRuntime.InvokeAsync<bool>("confirm", messagestring)))
        {
            _navManager.NavigateTo("/categoryproducts");
        }


    }
}
